{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "integral-prediction",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys,os,time\n",
    "import numpy as np\n",
    "from numba import jit\n",
    "os.environ['MPLCONFIGDIR'] = os.getcwd() + \"/configs/\"\n",
    "import matplotlib\n",
    "matplotlib.rcParams['text.latex.preamble']=r\"\\usepackage{bm} \\usepackage{amsmath}\"\n",
    "matplotlib.rc('text',usetex=True)\n",
    "from matplotlib.legend_handler import HandlerLine2D\n",
    "from matplotlib.colors import LogNorm\n",
    "import pylab as py\n",
    "new_path=\"/u/home/karki/.local/lib/python3.8/site-packages\"\n",
    "sys.path.append(new_path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "numerical-reunion",
   "metadata": {},
   "outputs": [],
   "source": [
    "os.environ[\"stflib\"] = \"./stflib\"\n",
    "from stflib import FUU,FUTsiv,FUTcol"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "knowing-elements",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.3201820465029111\n",
      "0.0009743468117990809\n",
      "0.007802022265034417\n"
     ]
    }
   ],
   "source": [
    "def test():\n",
    "    x=0.5;z=0.3;Q2=10.0;PhT=0.1\n",
    "    print(FUU.get_FUU(x,z,Q2,PhT,'p','pi+'))\n",
    "    print(FUTsiv.get_FUT(x,z,Q2,PhT,'p','pi+'))\n",
    "    print(FUTcol.get_FUT(x,z,Q2,PhT,'p','pi+'))\n",
    "test()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "scientific-xerox",
   "metadata": {},
   "outputs": [],
   "source": [
    "import params as par\n",
    "import alfa\n",
    "import dglap\n",
    "from   tools import lprint"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "cubic-dubai",
   "metadata": {},
   "outputs": [],
   "source": [
    "jit(nopython=True)\n",
    "\n",
    "def FUUT_modification(qT_Q,Q,FUUT_nomod,N=20, ctail=0.01):\n",
    "    R=np.exp(-N * np.power(qT_Q,3))\n",
    "    qT=Q*qT_QM\n",
    "    F_Tail=ctail/qT**2\n",
    "    FUU_mod_in=FUUT_nomod*R + (1 - R)*F_Tail\n",
    "    return FUU_mod_in\n",
    "\n",
    "def get_int0(xi,zeta,kinematics,iupol,isiv,icol,rotation=1):\n",
    "    \"\"\" \n",
    "     _..._ stands for non RC quantities \n",
    "     \"\"\"\n",
    "    M =par.M ## mass of proton 0.938 GeV\n",
    "    M_h=par.Mpi ## mass of pion 0.134 GeV\n",
    "   # print(\"Who is this\", M,\" m and h\", M_h)\n",
    "    \n",
    "    #--retrieve & build non RC quantities\n",
    "    _s_        =kinematics[0]\n",
    "    _Q_        =kinematics[1]\n",
    "    _x_        =kinematics[2]\n",
    "    _y_        =kinematics[3]\n",
    "    _z_        =kinematics[4]\n",
    "    _PhT_      =kinematics[5]\n",
    "    _cos_phih_ =kinematics[6]\n",
    "    _cos_phis_ =kinematics[7]\n",
    "    _sin_phih_ =kinematics[8]\n",
    "    _sin_phis_ =kinematics[9]\n",
    "    _ST_       =kinematics[10]\n",
    "\n",
    "    _l1T2_   = _Q_**2*(-M**2*_x_**2*_y_**2 - _Q_**2*_y_ + _Q_**2)/(_y_**2*(4*M**2*_x_**2 + _Q_**2))\n",
    "    _l1T_     = np.sqrt(_l1T2_)\n",
    "\n",
    "    _qdotPh_ = _Q_*(_Q_**3*_z_ - np.sqrt(-(4*M**2*_x_**2 + _Q_**2)*(4*M**2*M_h**2*_x_**2 + 4*M**2*_PhT_**2*_x_**2 - _Q_**4*_z_**2)))/(4*M**2*_x_**2)\n",
    "    _l1dotPh_= (-4*M**2*_PhT_*_l1T_*_x_**2*_y_*_cos_phih_ + 2*M**2*_x_**2*_y_*_qdotPh_ - \\\n",
    "               _PhT_*_Q_**2*_l1T_*_y_*_cos_phih_ - _Q_**4*_y_*_z_/2 + _Q_**4*_z_ + _Q_**2*_qdotPh_)/(_y_*(4*M**2*_x_**2 + _Q_**2)) \n",
    "    _l2dotPh_=_l1dotPh_-_qdotPh_ \n",
    "\n",
    "    _qdotS_  = -_Q_*np.sqrt(-(_ST_ - 1)*(_ST_ + 1)*(4*M**2*_x_**2 + _Q_**2))/(2*M*_x_)    \n",
    "    _l1dotS_ = (-4*M**2*_ST_*_l1T_*_x_**2*_y_*_cos_phis_ + 2*M**2*_x_**2*_y_*_qdotS_\\\n",
    "               - _Q_**2*_ST_*_l1T_*_y_*_cos_phis_ + _Q_**2*_qdotS_)/(_y_*(4*M**2*_x_**2 + _Q_**2))  \n",
    "\n",
    "    _l2dotS_=_l1dotS_-_qdotS_ \n",
    "\n",
    "    _eps_Pl1l2Ph_=-_PhT_*_Q_**2*_l1T_*np.sqrt(4*M**2*_x_**2/_Q_**2 + 1)*_sin_phih_/(2*_x_)\n",
    "    _eps_Pl1l2S_ =-_ST_ *_Q_**2*_l1T_*np.sqrt(4*M**2*_x_**2/_Q_**2 + 1)*_sin_phis_/(2*_x_)\n",
    "\n",
    "\n",
    "    #--build RC kinematic quantities\n",
    "    s        = xi*_s_\n",
    "    x        = _Q_**2*_x_*xi*_y_/(_Q_**2*(xi*zeta + _y_ - 1))\n",
    "    y        = (xi*zeta + _y_ - 1)/(xi*zeta)\n",
    "    z        = _y_*_z_*zeta/(xi*zeta + _y_ - 1)\n",
    "    Q2       = _Q_**2*xi/zeta\n",
    "    Q        = np.sqrt(Q2)        \n",
    "    gam2     = (2*M*x)**2/Q2\n",
    "    gam      = np.sqrt(gam2)\n",
    "\n",
    "    l1T2     = Q**2*(-M**2*x**2*y**2 - Q**2*y + Q**2)/(y**2*(4*M**2*x**2 + Q**2))\n",
    "    l1T      = np.sqrt(l1T2)\n",
    "\n",
    "    l1dotPh  = xi*_l1dotPh_\n",
    "    l2dotPh  = _l2dotPh_/zeta\n",
    "    l1dotS   = xi*_l1dotS_\n",
    "    l2dotS   = _l2dotS_/zeta\n",
    "\n",
    "    eps_Pl1l2Ph = (xi/zeta)*_eps_Pl1l2Ph_\n",
    "    eps_Pl1l2S  = (xi/zeta)*_eps_Pl1l2S_\n",
    "\n",
    "    qdotPh   = l1dotPh-l2dotPh \n",
    "    qdotS    = l1dotS-l2dotS \n",
    "\n",
    "    PhT2     = (-4*M**2*M_h**2*Q**2*x**2 - 4*M**2*x**2*qdotPh**2 - M_h**2*Q**4 + Q**6*z**2 + 2*Q**4*z*qdotPh)/(Q**2*(4*M**2*x**2 + Q**2))\n",
    "    PhT      = np.sqrt(np.abs(PhT2))\n",
    "    if  rotation==0: PhT=_PhT_\n",
    "\n",
    "    ST2      = (4*M**2*Q**2*x**2 - 4*M**2*x**2*qdotS**2 + Q**4)/(Q**2*(4*M**2*x**2 + Q**2))\n",
    "    ST       = np.sqrt(np.abs(ST2))\n",
    "    Spar     = 2*M*x*qdotS/(Q**2*np.sqrt(4*M**2*x**2/Q**2 + 1))\n",
    "\n",
    "    cos_phih = (4*M**2*x**2*y*qdotPh - Q**4*y*z + 2*Q**2*(Q**2*z + qdotPh)- 2*y*(4*M**2*x**2 + Q**2)*l1dotPh)/(2*PhT*l1T*y*(4*M**2*x**2 + Q**2))                    \n",
    "    cos_phis = (2*M**2*x**2*y*qdotS + Q**2*qdotS-y*(4*M**2*x**2 + Q**2)*l1dotS)/(ST*l1T*y*(4*M**2*x**2 + Q**2))\n",
    "\n",
    "    sin_phih = -2*x*eps_Pl1l2Ph/(PhT*Q**2*l1T*np.sqrt(4*M**2*x**2/Q**2 + 1))\n",
    "    sin_phis = -2*x*eps_Pl1l2S /( ST*Q**2*l1T*np.sqrt(4*M**2*x**2/Q**2 + 1))\n",
    "\n",
    "    if iupol==1: FUU_ = FUU.get_FUU(x,z,Q2,PhT,'p','pi+')\n",
    "    else:        FUU_ = 0\n",
    "        \n",
    "    #qT_Q=PhT/z/Q   \n",
    "    #FUU_ = FUUT_modification(qT_Q,Q,FUU_)\n",
    "    \n",
    "    if isiv==1: FUTsiv_ = FUTsiv.get_FUT(x,z,Q2,PhT,'p','pi+')\n",
    "    else:       FUTsiv_ = 0\n",
    "\n",
    "    if icol==1: FUTcol_ = FUTcol.get_FUT(x,z,Q2,PhT,'p','pi+')    \n",
    "    else:       FUTcol_ = 0\n",
    "\n",
    "    eps  = (1-y-0.25*gam2*y**2)/(1-y+0.5*y**2+0.25*gam2*y**2)\n",
    "    jac  = x/_x_/xi/zeta \n",
    "    norm = alfa.get_alfa(Q2)**2/(x*y*Q2) * y**2/2/(1-eps) * (1+gam2/2/x) \n",
    "\n",
    "    phase_sivers  = sin_phih*cos_phis - sin_phis*cos_phih\n",
    "    phase_collins = sin_phih*cos_phis + sin_phis*cos_phih\n",
    "\n",
    "\n",
    "    out=jac*norm*(FUU_ + ST*phase_sivers*FUTsiv_ + ST*eps*phase_collins*FUTcol_)\n",
    "    #print(out)\n",
    "    return out\n",
    "\n",
    "\n",
    "@jit(nopython=True)\n",
    "def get_xi_min(zeta,kinematics):\n",
    "    y,x,z=kinematics[3],kinematics[2],kinematics[4]\n",
    "    return max([(1-y+z*zeta*y)/zeta,(1-y)/(zeta-x*y)])\n",
    "\n",
    "@jit(nopython=True)\n",
    "def get_zeta_min(kinematics):\n",
    "    y,x,z=kinematics[3],kinematics[2],kinematics[4]\n",
    "    return max([(1-y)/(1-z*y),1-y+x*y])   \n",
    "\n",
    "@jit(nopython=True)\n",
    "def get_box(xi,zeta,kinematics,F,jac_xi,mu2,iupol,isiv,icol,rotation=1):\n",
    "    xi_min =get_xi_min(zeta,kinematics)\n",
    "    LDF    =dglap.get_LDF(xi,F,mod=False)\n",
    "    LDF2   =dglap.get_LDF(xi_min,F,mod=True)\n",
    "    int0_xi_zeta =get_int0(xi,zeta,kinematics,iupol,isiv,icol,rotation=1)\n",
    "    int0_one_zeta=get_int0(1,zeta,kinematics,iupol,isiv,icol,rotation=1)\n",
    "    return LDF*(int0_xi_zeta-int0_one_zeta)*jac_xi +int0_one_zeta*xi_min*LDF2\n",
    "\n",
    "@jit(nopython=True)\n",
    "def get_integrand0(X,kinematics,F,D,iupol,isiv,icol,rotation=1):\n",
    "    mu2=kinematics[1]**2\n",
    "    zeta_min=get_zeta_min(kinematics)\n",
    "    jac_zeta=1-zeta_min\n",
    "    zeta=zeta_min + X[0]*jac_zeta\n",
    "\n",
    "    xi_min=get_xi_min(zeta,kinematics)\n",
    "    jac_xi=1-xi_min\n",
    "    xi=xi_min + X[1]*jac_xi\n",
    "    \n",
    "\n",
    "    LFF =dglap.get_LFF(zeta,D,mod=False)\n",
    "    LFF2=dglap.get_LFF(zeta_min,D,mod=True)\n",
    "        \n",
    "    box_xi_zeta=get_box(xi,zeta,kinematics,F,jac_xi,mu2,iupol,isiv,icol,rotation)\n",
    "    box_xi_one =get_box(xi,1,kinematics,F,jac_xi,mu2,iupol,isiv,icol,rotation)\n",
    "\n",
    "    theta=1\n",
    "    if xi<get_xi_min(1,kinematics): theta=0\n",
    "    integrand=LFF*(box_xi_zeta-box_xi_one*theta)*jac_zeta + box_xi_one*theta*zeta_min*LFF2\n",
    "    #print(box_xi_zeta,box_xi_one,integrand)\n",
    "\n",
    "    return integrand\n",
    "\n",
    "@jit(nopython=True)\n",
    "def get_integrand1(X,kinematics,F,D,iphih,iphis,iupol,isiv,icol,qed_order=1,rotation=1):\n",
    "    phis=-np.pi + 2*np.pi*X[2]\n",
    "    phih=-np.pi + 2*np.pi*X[3]\n",
    "    kinematics[6] = np.cos(phih)\n",
    "    kinematics[7] = np.cos(phis)\n",
    "    kinematics[8] = np.sin(phih)\n",
    "    kinematics[9] = np.sin(phis)\n",
    "    jac   = (2*np.pi)**2\n",
    "    phase = np.sin(iphih*phih+iphis*phis)*jac\n",
    "    if qed_order==0:\n",
    "        int0=get_int0(1,1,kinematics,iupol,isiv,icol,rotation)\n",
    "        out=int0*phase\n",
    "\n",
    "    elif qed_order==1:\n",
    "        integrand0=get_integrand0(X,kinematics,F,D,iupol,isiv,icol,rotation)\n",
    "        out=integrand0*phase\n",
    "\n",
    "    if np.isnan(out): out=0\n",
    "    return out\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "stone-faculty",
   "metadata": {},
   "outputs": [],
   "source": [
    "import vegas\n",
    "\n",
    "def get_xsec(kinematics\n",
    "             ,iphih,iphis\n",
    "             ,iupol,isiv,icol\n",
    "             ,qed_order\n",
    "             ,dglap_order,rotation\n",
    "             ,nbiter,nburn,neiter,neval,ftol=1e-8):\n",
    "    Q=kinematics[1]\n",
    "    mu2=Q**2\n",
    "    F,D=dglap.evolve(mu2,dglap_order)\n",
    "    trial=1\n",
    "\n",
    "    #imin=5 ;imax=10\n",
    "    imin=10;imax=100\n",
    "\n",
    "    results=[]\n",
    "\n",
    "    while 1:    \n",
    "        integ = vegas.Integrator([[0, 1] for _ in range(4)])\n",
    "        func=lambda X:get_integrand1(X,kinematics,F,D,iphih,iphis,iupol,isiv,icol,qed_order,rotation)\n",
    "        integ(func, nitn=nbiter, neval=nburn)        # burn\n",
    "        result=integ(func, nitn=neiter, neval=neval) # final\n",
    "        results.append(result.val)\n",
    "        if len(results)<=imin:\n",
    "            lprint('size=%d'%len(results))\n",
    "            continue\n",
    "        mean=np.mean(results)\n",
    "        std =np.std(results)\n",
    "\n",
    "        lprint('trial=%d size=%d mean=%0.2e std=%0.2e rel=%0.2e'%(trial,len(results),mean,std,std/mean))\n",
    "        if (std/mean)<ftol:break        \n",
    "        if len(results)>imax:\n",
    "            results=[]\n",
    "            nburn *=10\n",
    "            neiter*=10\n",
    "            trial +=1\n",
    "            print()\n",
    "            \n",
    "\n",
    "            \n",
    "    return mean,std"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "alone-dayton",
   "metadata": {},
   "outputs": [],
   "source": [
    "def test(rotation): \n",
    "    \n",
    "    rs  = 140\n",
    "    #x   = 0.01 # xb=0.32\n",
    "    z   = 0.5 #0.55\n",
    "    Q   =5\n",
    "    y=0.4\n",
    "    qT_Q= 0.5 #qT/Q \n",
    "    ### pt_square = 0.01 to 0.19 \n",
    "    \n",
    "    #sqrt(s) = 2(sqrt E_e x E_p)\n",
    "  \n",
    "    # FIXED ANGLE FOR UNPOLARIZED \n",
    "    phih = 0\n",
    "    phis = 0\n",
    "    iphih = 0  \n",
    "    iphis = 0   \n",
    "    \n",
    "    iupol = 1 \n",
    "    isiv  = 0 \n",
    "    icol  = 0\n",
    "    qed_order  = 1\n",
    "    dglap_order= 1\n",
    "    \n",
    "    if iupol==1:\n",
    "        iphase = 0\n",
    "    else:\n",
    "        iphase = 1\n",
    "\n",
    "    nbiter,nburn = 1,1000\n",
    "    neiter,neval = 1,10000\n",
    "    ftol=1e-2\n",
    "\n",
    "\n",
    "    \n",
    "    if qed_order==0:\n",
    "        RC_status=\"noQED\"\n",
    "    else: RC_status=\"QED\"\n",
    "\n",
    "   \n",
    "    #f = open(\"Unp_Q{}_rs140_const_alpha_QED_noROT.txt\".format(Q), \"w\")\n",
    "    while(qT_Q<0.52):\n",
    "        x   =Q**2/rs**2/y\n",
    "        qT  =qT_Q*Q\n",
    "        PhT =z*qT\n",
    "        ST  =1\n",
    "        kinematics=np.zeros(11)\n",
    "        kinematics[0] = rs**2\n",
    "        kinematics[1] = Q\n",
    "        kinematics[2] = x\n",
    "        kinematics[3] = y\n",
    "        kinematics[4] = z\n",
    "        kinematics[5] = PhT\n",
    "        \n",
    "        kinematics[6] = np.cos(phih)\n",
    "        kinematics[7] = np.cos(phis)\n",
    "        kinematics[8] = np.sin(phih)\n",
    "        kinematics[9] = np.sin(phis)\n",
    "        \n",
    "        kinematics[10]= ST\n",
    "        f_zeta=0.76\n",
    "        while f_zeta <1.01:\n",
    "            f_xi=1\n",
    "            #f_zeta=1\n",
    "            LO=get_int0(f_xi,f_zeta,kinematics,iupol,isiv,icol,rotation)\n",
    "            f_zeta+=0.01\n",
    "        qT_Q+=0.5;\n",
    "test(1)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
